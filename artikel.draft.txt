Mit Wicket 1.5 ist es so einfach wie nie, Ajax basierte Webapplikationen zu erstellen.

Wie einfach das geht und wieviel Spaß das machen kann will dieser Artikel zeigen.

Zunächst erzeugen wir uns eine sehr einfache Wicket-Applikation:

[code]

mvn archetype generate

[/code]

mit der Nummer 217.

Anschließend passen wir die Version in der pom noch an (im Moment wird über den Maven Archetype die Version 1.5.0 noch nicht angeboten.

Hier ist das Gradle-Build File (es gibt aber auch ein Maven Pom):

[code]

apply plugin: 'java'
apply plugin: 'eclipse'

defaultTasks "build"

version = "1.0-SNAPSHOT"

springVersion = '3.0.5.RELEASE'
wicketVersion = '1.5.0'
jettyVersion = '7.3.0.v20110203'

sourceCompatibility = 1.6
targetCompatibility = 1.6

dependencies {
compile  "org.apache.wicket:wicket:$wicketVersion"
compile  "org.apache.wicket:wicket-extensions:$wicketVersion"
compile  "org.apache.wicket:wicket-spring:$wicketVersion"
compile  "org.apache.wicket:wicket-datetime:$wicketVersion"
compile  'org.slf4j:slf4j-log4j12:1.5.8'
compile  "org.springframework:spring-core:$springVersion"
compile  "org.springframework:spring-beans:$springVersion"
compile  "org.springframework:spring-jdbc:$springVersion"
compile  "org.springframework:spring-web:$springVersion"
compile  "org.springframework:spring-orm:$springVersion"
compile  "org.springframework:spring-test:$springVersion"
testCompile     "junit:junit:4.8.1"
testCompile     "org.mockito:mockito-core:1.8.5"
testCompile "org.eclipse.jetty.aggregate:jetty-all-server:$jettyVersion"

}

sourceSets {
main {
resources {
srcDir 'src/main/resources'
srcDir 'src/main/java'
}
}
test {
resources {
srcDir 'src/test/resources'
srcDir 'src/test/java'
}
}
}

repositories {
mavenCentral()
}

[/code]

Zunächst räumen wir die Applikation noch ein wenig auf, damit wir wirklich "auf der grünen Wiese" anfangen können.
Die Page sollte so aussehen:

[code language="java"]
public class HomePage extends WebPage {
private static final long serialVersionUID = 1L;

public HomePage(final PageParameters parameters) {
}
}
[/code]

Anschließend löschen wir noch die Klasse "TestHomePage" unter src/test/java, Testen kann hier nicht das Thema.

Zunächst mal schauen wir uns grundsätzlich an, wie Wicket im Zusammenspiel mit Ajax überhaupt funktioniert.

Im nächsten Schritt werden wir einige Funktionale Elemente einbauen (TextFelder etc,)

Anschließend werden wir uns die Integration mit der meiner Ansicht nach coolsten Ajax-Engine die aktuell verfügbar ist anschauen.

Anschließend werden wir einen Blick auf den neuen Wicket Event Mechanismus werfen.

Der Source-Code ist übrigens verfügbar, und zwar hier. Alle wichtigen Schritte sind jeweils getaggt. Ich werde im Artikel darauf verweisen.

Im Package "src/test/java" befindet sich übrigens die Klasse Start, diese hat eine main()-Methode und startet einen Embedded-Jetty, d.h. die Applikation ist direkt aus Eclipse heraus startbar.

Schritt 1 - die Wicket Ajax Engine

Wicket ist ein etabliertes Webframework und kommt mit einer schlanken aber brauchbaren Ajax-Engine daher.

Was bietet die Wicket Ajax Engine?

    Abstraktion von Browser-Inkompatibilitäten
    Abstraktion der Ajax-Requests
    Parallele / Synchrone Verarbeitung von Ajax-Requests

Betrachten wir doch mal, wie die AjaxEngine grundsätzlich aufgebaut ist. Hierfür fügen wir in die Form einen einfachen AjaxLink ein.

Wicket bietet von Haus aus schon eine ganze Menge an Komponenten, die Ajax-Funktionalität Out-of-the-Box mitbringen. Der Ajax-Link ist eine davon - Ein Link der einen Ajax-Request an den Server sendet.

Folgendes Fragment bauen wir in das Html der Seite ein.

[code language="html"]

<a href="#" wicket:id="ajaxLink"/>

[/code]

Im Java Code das Pendant dazu.

[code language="java"]

add(new AjaxLink("ajaxLink"){
@Override
public void onClick(AjaxRequestTarget target) {
target.appendJavaScript("alert('hello world!');");
}
});

[/code]


Die Implementierung spielt momentan keine Rolle, dazu kommen wir später noch. Zunächst mal wollen wir uns anschauen, was Wicket uns generiert hat.
Hierzu betrachten wir den Quellcode der generierten Webseite.

[code language="java"]
<a href="<a href="view-source:http://localhost:8080/?0#">#</a>" wicket:id="ajaxLink" id="ajaxLink1" onclick="var wcall=wicketAjaxGet('wicket/page?0-1.IBehaviorListener.0-ajaxLink',function() { }.bind(this),function() { }.bind(this), function() {return Wicket.$('ajaxLink1') != null;}.bind(this));return !wcall;">Click me</a>
[/code]

Besonders interessant ist natürlich der onclick-Handler des Links:

[code language="javascript"]
var wcall=wicketAjaxGet('wicket/page?0-1.IBehaviorListener.0-ajaxLink',function() { }.bind(this),function() { }.bind(this), function() {return Wicket.$('ajaxLink1') != null;}.bind(this));return !wcall;"
[/code]

Um zu verstehen, was das bedeutet betrachten wir uns gleichzeitig die Implementierung der entsprechenden Stelle in den Wicket-Sources.
Die Javascript Implementierung befindet sich im Modul wicket-core in der Datei wicket-ajax.js.

[code language="javascript"]
function wicketAjaxGet(url, successHandler, failureHandler, precondition, channel) {

var call = new Wicket.Ajax.Call(url, successHandler, failureHandler, channel);

if (typeof(precondition) != "undefined" && precondition != null) {
call.request.precondition = precondition;
}

return call.call();
}
[/code]

Die wicketAjaxGet-Routine hat also folgende Parameter:

[code language="javascript"]
url, successHandler, failureHandler, channel
[/code]

Die Parameter sind folgendermaßen belegt:

[code language="java"]
url : wicket/page?0-1.IBehaviorListener.0-ajaxLink
successHandler : function() { }.bind(this)
failureHandler :function() { }.bind(this)
channel :function() {return Wicket.$('ajaxLink1') != null;}.bind(this));
[/code]

Ok, schauen wir uns ein wenig genauer an, wie der Wicket-Ajax-Mechanismus überhaupt funktioniert.
Die Url wicket/page?0-1.IBehaviorListener.0-ajaxLink adressiert ein AjaxBehavior.

Wicket Behaviors bieten die einfache Möglichkeit, zusätzliches Verhalten für Wicket-Komponenten zu definieren.
Im folgenden Code-Schnipsel wird das grob veranschaulicht.
Zunächst definieren wir im Html ein einfaches div-Element zur Anzeige eines Textes.

[code language="html"]
<div wicket:id="ajaxText"/>
[/code]

und zusätzlich folgenden Java-Code:

[code language="java"]
Label label = new Label("ajaxText","Ajax Clickable Text");
add(label);
label.add(new AjaxEventBehavior("onclick"){

@Override
protected void onEvent(AjaxRequestTarget target) {
target.appendJavaScript("alert('clicked')");
}});
[/code]

Auf diese Art und Weise kann praktisch jedes Element ajaxifiziert werden.
Wie aber kommt man jetzt vom Javascript auf der Clientseite zum Serverseitigen Code?

Ganz einfach, über die URL.

[code language="javascript"]
wicket/page?0-1.IBehaviorListener.0-ajaxLink
[/code]

Hiermit wird die PageMap 0 adressiert, in dieser PageMap die Page mit der Version 1. Adressiert wird ein IBehaviorListener, und zwar
mit der Version 0 das auf der Komponente mit der ID "ajaxLink" liegt.
Wenn euch genauer interessiert, wie diese URL geparsed wird, könnt ihr beispielsweise die Klasse PageInstanceMapper genauer unter die Lupe
nehmen.

Das Schema einer URL ist in der Klasse URL definiert (natürlch die in den wicket-packages...)


Hier wird beispielsweise auch aus dem String IBehaviorListener die entsprechende Klasse erzeugt, das Mapping hierzu findet ihr in der KLasse
RequestListenerInterface.

Anschließend wird in der Klasse ListenerInterfaceRequestHandler die eigentliche Requestverarbeitung angestossen.

Ok, aber das könnt ihr alles selber sehen, wenn ihr einfach mal den Debugger anschmeißt und schaut, was passiert. Ich kann das nur empfehlen, ist wirklich hochinteressant.

Ok, lange Rede kurzer Sinn, was Wicket macht, wenn man diese URL aufruft (die man übrigens auch problemlos einfach im Browser aufrufen könnte), es mappt den Request in ein AjaxRequestTarget.

Überhaupt lohnt sich ein etwas genauerer Blick in die Klasse RequestListenerInterface und in die Klasse RequestCycle, da hier viel passiert und man sich relativ schnell ein Verständnis aufbauen kann, wie die Requestverarbeitung in Wicket funktioniert.

Nochmal zur Erinnerung die RequestParameter:

[code language="java"]
url : wicket/page?0-1.IBehaviorListener.0-ajaxLink
successHandler : function() { }.bind(this)
failureHandler :function() { }.bind(this)
channel :function() {return Wicket.$('ajaxLink1') != null;}.bind(this));
[/code]
SuccessHandler ist leer, d.h. es gibt keine bestimmte AKtion, wenn der Ajax-Requets erfolgreich ist.

Das Gleiche gilt für den Failure-Handler, sollte der Ajax Request fehlschlagen, dann schlägt der AjaxRequest eben fehl.
Ich hatte das Problem schon mehrfach in diversen Projekten, dass die Infrastruktur uns einen Strich durch die Rechnung macht - 
beispielsweise Firewalls, Loadbalancer etc., in diesen Fällen wird der FailureHandler plötzlich sehr interessant.

Wie aber kann ich als Entwickler jetzt diese Success- bzw. FailureHandler setzen.

Hierzu schauen wir uns kurz mal die Klasse AbstractDefaultAjaxRequestTarget an.
[code language="java"]
	/**
	 * @return javascript that will run when the ajax call finishes with an error status
	 */
	protected CharSequence getFailureScript()
	{
		return null;
	}

	/**
	 * @return javascript that will run when the ajax call finishes successfully
	 */
	protected CharSequence getSuccessScript()
	{
		return null;
	}

[/code]

Das sollte uns jetzt schon bekannt vorkommen.
Wo wird das aber nun aufgerufen?

Hierzu schaut ihr euch am besten in AbstractDefaultAjaxBehavior mal die Methode 
[code language="java"]
protected CharSequence generateCallbackScript(final CharSequence partialCall)
[/code]

an.

Am besten wirds sein, wir implementieren einfach mal den Success- bzw. auch den FailureHandler.
Wir haben noch das AjaxEventBehavior von vorhin.
Hier implementieren wir noch die zuvor erwähnten Methoden.

[code language="java"]
label.add(new AjaxEventBehavior("onclick"){

			@Override
			protected void onEvent(AjaxRequestTarget target) {
				target.appendJavaScript("alert('clicked')");
			}
		    
			@Override
			protected CharSequence getFailureScript() {
				return "alert('there was a failure!!')";
			}
			
			@Overridearauf 
			protected CharSequence getSuccessScript() {
				return "alert('Ajax call was successful')";
			}
    	});
[/code]


*** TODO succesful ajax call ***

Das Gleiche versuchen wir jetzt mal mit einem AjaxFehler. Nehmen wir beispielsweise den HTTP-Errorcode 503 (Gateway bzw. Server antwortet nicht).
Darauf müssen wir in einer Applikation normalerweise reagieren.
Das zu simulieren ist natürlich nicht ganz so trivial wie der Succes-Fall, aber weit weniger kompliziert, wie erwartet.

Beispielsweise könnten wir in der onEvent-Methode des AjaxBehaviors einfach einen HTTP-Fehlercode zurückgeben.

[code language="java"]
@Override
protected void onEvent(AjaxRequestTarget target) {
	throw new AbortWithHttpErrorCodeException(503, "I need to check that");
]
[/code]

*** TODO failure ajax call ***

Mit einer normalen Exception funktioniert das übrigens nicht, denn das ist kein HTTP-Fehler und wird Serverseitig behandelt und zeigt normalerweise eine ErrorPage oder sowas an.

